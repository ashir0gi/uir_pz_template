\chapter{Реализация и экспериментальная проверка}
\label{chapter4}

В этой главе описывается, как была реализована система пошаговой бета-редукции и её синтаксические анализаторы на платформе .NET/F\#. Приведены ключевые фрагменты кода, описаны инструменты, структура ПО, сценарии работы, тестовые примеры и сравнительный анализ с существующими решениями.

\section{Выбор инструментальных средств}
Для реализации использовались:
\begin{itemize}
  \item Платформа \textbf{.NET 8.0+} и язык \textbf{F\#} — за выразительность в работе с AST и рекурсивными типами.
  \item Библиотека \textbf{FParsec} для построения парсера в комбинаторном стиле.
  \item NUnit для модульного тестирования.
  \item Visual Studio / Rider для разработки и отладки.
\end{itemize}

\section{Состав и структура реализованного ПО}
Реализовано как F\#-библиотека (NuGet-пакет):
\begin{itemize}
  \item \texttt{BetaReduction.Parser} — модуль конфигурируемого парсера;
  \item \texttt{BetaReduction.Machine} — абстрактная машина пошаговой редукции;
  \item \texttt{BetaReduction.Environment \& Atomic} — определения атомиков и окружения;
  \item \texttt{BetaReduction.Tests} — проект с NUnit-тестами.
\end{itemize}

\section{Основные сценарии работы}
\begin{enumerate}
  \item \textbf{Разбор выражения:} 
    \[
      \texttt{let term = BRParser().Parse("\textbackslash x -> x x")}
    \]
    — возвращает AST (\texttt{ITerm}).
  \item \textbf{Пошаговая редукция:} 
    \[
      \texttt{let state = BetaReductor(cfg).EvaluateCode(code, true)}
    \]
    — один шаг.
  \item \textbf{Полная нормализация:} 
    \[
      \texttt{BetaReductor(cfg).EvaluateCode(code, false)}
    \]
    — до нормальной формы.
\end{enumerate}

\section{Ключевые фрагменты кода}

\subsection{Настройка парсера}
Комбинаторный подход на FParsec: конфигурация операторов и колбэков вынесена в отдельный блок, что упрощает расширение:

\begin{lstlisting}[
  float=tb,frame=lines,
  label=lst:parser-config,
  caption=Конфигурация BRParser: операторы, ключевые слова и колбэки
]
// определить унарные и бинарные операторы с приоритетами
let brUnOps = [ UnOp {| keyword = "-"; term = atomicUnOpMinus; priority = 1 |} ]
let brBinOps = [
  BinOp {| keyword = "+"; term = atomicBinOpPlus;   priority = 1; associativity = Associativity.Left |}
  BinOp {| keyword = "*"; term = atomicBinOpMult;   priority = 2; associativity = Associativity.Left |}
  // ...
]

// объединить в конфиг
let cfg = {
  applicationTff     = appTff
  simpleLambdaTff    = SimpleLambdaTff(subs)
  multiLambdaTff     = Some (MultiLambdaTff(subs))
  operators          = brUnOps @ brBinOps
  keywords           = ["true"; "false"; "Y"; "NULL"]
  parseNumericConsts = true
  ifStatements       = false
}

// привязать колбэки для переменных, чисел, ключевых слов
p.pVariableCallback <- fun name -> DefaultVariable(name) :> ITerm
p.pNumericCallback  <- fun n    -> match n with Int i -> Data.Int i | Float f -> Data.Float f
p.pKeywordCallback  <- function
  | "true"  -> Data.Bool true
  | "false" -> Data.Bool false
  | kw      -> raise (BRParsingException ...)
\end{lstlisting}

Пример задания конфигурации BRParser представлен в листинге \ref{lst:parser-config}.

\subsection{Механизм одного шага редукции}
Внутри \texttt{BetaReductor} ключевая функция \texttt{step} обрабатывает:
\begin{itemize}
  \item \textbf{β-редексы:} $(\lambda x.M)\,N \to M[x:=N]$;
  \item \textbf{спуск внутрь:} если редексов нет, рекурсивно обходит подтермы;
  \item \textbf{атомарные функции:} вызывает \texttt{IFunction.ReduceWithArguments}.
\end{itemize}

\begin{lstlisting}[
  float=tb,frame=lines,
  label=lst:machine-step,
  caption=Алгоритм одного шага в BetaReductor
]
let rec step term =
  match term with
  | :? IApplicationTerm as app ->
      match app.Function with
      | :? SimpleLambda as lam ->
          // бета-редукция: подстановка первого аргумента
          let arg = Seq.head app.Arguments
          substitution.Substitute(lam.Body, seq { lam.Variable, arg })
      | f when f :? IFunction ->
          // атомарный вызов
          f.ReduceWithArguments(app.Arguments, tff)
      | _ ->
          // спуск внутрь
          // 1) пытаемся step(f)
          // 2) если не изменилось, пробуем step на каждом аргументе
          term
  | :? IFunctionalAbstraction as lam ->
      // спуск внутрь тела λ
      let body' = step lam.GetBody
      if not (obj.ReferenceEquals(body', lam.GetBody)) then
        // пересоздать лямбду с новым телом
        SimpleLambda(lam.GetBoundVariable, body', substitution) :> ITerm
      else term
  | _ -> term
\end{lstlisting}

Алгоритм шага редукции представлен в листинге \ref{lst:machine-step}.

\section{Разработка тестовых примеров}
\label{sec:test-examples}

Для обеспечения надёжности и корректности работы как парсера, так и абстрактной машины бета‑редукции, был разработан обширный набор NUnit‑тестов.

\subsection{Тесты парсера}

Нижеследующие аспекты разбора покрываются тестами из модуля \texttt{ParseTest}:

\begin{itemize}
  \item \textbf{Лямбда‑абстракции:} проверяется, что строка вида \verb|\ x -> x| корректно преобразуется в \texttt{SimpleLambda}.  
  \item \textbf{Унарные и бинарные операторы:} приоритеты и ассоциативность обрабатываются в соответствии с конфигурацией \texttt{unOps} и \texttt{binOps}.  
  \\
  \item \textbf{Вложенные абстракции и приложения:} тестируются случаи \(\lambda x.\,\lambda y.\,\lambda z.\,y\) и \((\lambda x.\,x+x)\,5\).  
  \item \textbf{Скобочные конструкции:} проверяется различие между \(\,x + x - x\) и \(\,x + (x - x)\).  
  \item \textbf{Ключевые слова:} пользовательские ключевики (\texttt{magicWord0}, \texttt{magicWord1}) обрабатываются через колбэк \texttt{pKeywordCallback}.  
\end{itemize}

\begin{lstlisting}[float=tb,frame=lines,label=lst:parser-test-example,caption={Пример теста для скобочных выражений}]
[<Test>]
member this.Parentheses() =
  let noPar = "\\ x -> x plus x - x"
  let withPar = "\\ x -> x plus (x - x)"
  let gotNo = callParse2String(parser, noPar)
  let gotPar = callParse2String(parser, withPar)
  Assert.That(gotNo, Is.EqualTo(expectedNo))
  Assert.That(gotPar, Is.EqualTo(expectedPar))
\end{lstlisting}

Пример теста для скобочных выражений представлен в листинге \ref{lst:parser-test-example}.

\subsection{Тесты бета‑редуктора}

Тестовый модуль \texttt{BetaReductionTests} проверяет корректность шаговой и полной редукции:

\begin{itemize}
  \item \textbf{Один шаг vs. полная нормализация:} для терма \((\lambda x.\,x\,x)\,x\) сравнивается результат одного шага и финальной формы.  
  \item \textbf{Последовательность шагов:} функция \texttt{reduceStepByStep} строит весь путь редукции, и каждый промежуточный результат сравнивается с ожидаемым списком строковых представлений термов.  
  \item \textbf{Атомарные операции:} проверка встроенных бинарных операций, например \((+\,1\,2)\to 3\).  
  \item \textbf{Композиция λ‑выражений:} тесты для вложенных абстракций, например \(((\lambda x.\,x)\,(\lambda x.\,x))\) приводят к корректному результату.  
\end{itemize}

\begin{lstlisting}[float=tb,frame=lines,label=lst:reductor-step-test,caption={Проверка последовательности шагов редукции}]
[<Test>]
member _.``step by step plus``() =
  let plus = Data.BinOp("+", fun a b -> match a,b with Int x,Int y -> Int(x+y) | _ -> failwith "")
  let term = applicationTff.CreateTerm([ plus; Data.Int 1; Data.Int 2 ])
  let seq = reduceStepByStep reductor (term2Code term)
  Assert.That(seq |> List.last, Is.EqualTo("Int 3"))
\end{lstlisting}

Проверка последовательности шагов редукции представлена в листинге \ref{lst:reductor-step-test}.


\section{Сравнение с существующими аналогами}
\begin{table}[h]
\centering\small
\caption{Сравнение реализованного ПО и аналогов}
\begin{tabular}{|l|l|l|l|}
\hline
Инструмент & Язык    & Стратегии       & Комментарий                   \\ \hline
Mace       & F\#     & Normal, Full    & Модульность, .NET-интеграция \\ \hline
GHCi       & Haskell & Call-by-Need    & Высокая производительность    \\ \hline
Coq        & OCaml   & Call-by-Value   & Формальное доказательство     \\ \hline
\end{tabular}
\end{table}

\section{Выводы}
\begin{itemize}
  \item Показана эффективность FParsec-комбинаторов для настраиваемого парсинга.
  \item Абстрактная машина легко расширяется под новые стратегии.
  \item Тесты подтверждают корректность и устойчивость реализации.
  \item Проект готов к интеграции в образовательные и исследовательские среды на .NET.
\end{itemize}
